{
  "hash": "d506a93f1eb2ca2ed5cdc7723af9d301",
  "result": {
    "markdown": "---\ntitle: \"Visualizing CNNs\"\nauthor: \"Aleksandra Muciek\"\ntoc: true\nformat: \n    html: \n        code-fold: true\n---\n\nEven though the concept of convolutional neural networks is not new to me, I noticed a gap in my understanding. I couldn't figure out how to approach visualization of convolutional neural network layers' weights. It alweays seemed odd to me when I looked at examples found online. \n\nHere I will try to explore the concept to teach myself this interesting thing.\n\n## Convolutional neural nets\n\nIn convolutional neural networks we operate on images. Each one is 2D grid of values representing every pixel. If the picture is in grayscale we only care for how dark or light each pixel is, so each image is represented as grid $n_{row} \\times n_{col}$ with values representing darkness of each pixel.\n\nIf we use color pictures, we divide it into $3$ channels - red, green, blue. For image with pixel size $n_{row} \\times n_{col}$ we use one grid for red coulour, second for green and third for blue. This means each picture is represented with 3 grids one on top of the other. Dimensionality of this thing is $(n_{row}, n_{col}, 3)$.\n\n![Layers of images. On the left grayscale image represented by only one matrix, on the right 3 channels of a colorful image.](imgaes_layers.png)\n\n### Filters\n\nFilters are introduced to smartly downscale an image while distilling the most important information convayed by the image. If we go back to grayscale setting, and assume we have $(n_{row}, n_{col}, 1)$ image, a single grid with pixel values, we introduce filter, for example $2 \\times 2$ matrix that will be put on top of the image, place by place where it fits. Then we will calculate elementwise product of each overlaping entries, sum the values and we will end up with a smaller image.\n\n![Example of grayscale image and $2\\times 2$ filter](grayscale_image_and_filter.png)\n\n\n![Applying $2 \\times 2$ filter to the example above.](applying_filters.png)\n\nWhile constructing a concloutional layer in the model, we specify the size of a filter ($2 \\times 2$, $3 \\times 3$ etc.) and we decide on the number of filters we want to apply. In the example above we used only one filter but we could repeat the above process with the second one with different values than $(1, 0),(2, 4)$. In the example above we got output  with dimensions $(3, 3, 1)$. If we chose to apply second filter we would get second result, so overal thing would have dimensions $(3, 3, 2)$. For specified number of filters $k$ we would get $(3, 3, k)$ dimensional tensor. \n\nValues of the filters are not specified by us before training - they are learned by the model. These are the things we may want ti visualize later to see how the model behaves.\n\n## Get convolutional model\n\nWe get a trained model from `keras` package called VGG16. Out of this model we will look for convolutional layers.\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\n\n\nfrom keras.applications.vgg16 import VGG16\nmodel = VGG16()\n\n#model.summary()\n\nfor idx, layer in enumerate(model.layers):\n    if 'conv' in layer.name:\n        filters, biases = layer.get_weights()\n        print(f\"Index: {idx})\", layer.name, filters.shape)\n\n#weights from the second layer\n\nfilters, biases = model.layers[1].get_weights()\n\n#scaling\nf_min, f_max = filters.min(), filters.max()\nfilters = (filters - f_min) / (f_max - f_min)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIndex: 1) block1_conv1 (3, 3, 3, 64)\nIndex: 2) block1_conv2 (3, 3, 64, 64)\nIndex: 4) block2_conv1 (3, 3, 64, 128)\nIndex: 5) block2_conv2 (3, 3, 128, 128)\nIndex: 7) block3_conv1 (3, 3, 128, 256)\nIndex: 8) block3_conv2 (3, 3, 256, 256)\nIndex: 9) block3_conv3 (3, 3, 256, 256)\nIndex: 11) block4_conv1 (3, 3, 256, 512)\nIndex: 12) block4_conv2 (3, 3, 512, 512)\nIndex: 13) block4_conv3 (3, 3, 512, 512)\nIndex: 15) block5_conv1 (3, 3, 512, 512)\nIndex: 16) block5_conv2 (3, 3, 512, 512)\nIndex: 17) block5_conv3 (3, 3, 512, 512)\n```\n:::\n:::\n\n\n## Plot some filters\n\nHere are presented some filters.\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nimport matplotlib.pyplot as plt\n\nnum_filters = 4\n\nfig, axs = plt.subplots(num_filters, filters.shape[2], sharey=True, figsize=(8, 12))\nfig.suptitle(\"Visualization of weights\")\nfor i in range(num_filters):\n    filter_0 = filters[:,:,:, i]\n    for j in range(filter_0.shape[2]):\n        axs[i,j].imshow(filter_0[:,:, j], cmap='gray')\n```\n\n::: {.cell-output .cell-output-display}\n![Every row is a visualized $3 \times 3$ filter with every column being a channel of that filter. ](weights_cv_files/figure-html/fig-bnwfilters-output-1.png){#fig-bnwfilters}\n:::\n:::\n\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nfig, axs = plt.subplots(5, 5, sharey=True, figsize = (8,8))\nfig.suptitle(\"Filters with all 3 channels\")\nfor i in range(5):\n    for j in range(5):\n        axs[i, j].imshow(filters[:,:,:, i*5 + j])\n```\n\n::: {.cell-output .cell-output-display}\n![](weights_cv_files/figure-html/cell-4-output-1.png){}\n:::\n:::\n\n\n## Additional section to play with widgets\n\n## Useful links \n\n",
    "supporting": [
      "weights_cv_files"
    ],
    "filters": [],
    "includes": {}
  }
}